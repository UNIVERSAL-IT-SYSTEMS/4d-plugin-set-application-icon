/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Set Application Icon
 #	author : miyako
 #	2016/05/30
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Set Application Icon

		case 1 :
			SET_APPLICATION_ICON(pResult, pParams);
			break;

	}
}

// ----------------------------- Set Application Icon -----------------------------

#pragma mark -

void getPNG(PA_Picture *picture, std::vector<uint8_t> &buf)
{
	std::string type(".png");
	buf.clear();
	PA_ErrorCode err = eER_NoErr;
	unsigned i = 0;
	PA_Unistring t;
	std::map<CUTF8String, uint32_t> types;
	while (err == eER_NoErr)
	{
		t = PA_GetPictureData(*picture, ++i, NULL);
		err = PA_GetLastError();
		if(err == eER_NoErr)
		{
			uint32_t len = (uint32_t)(t.fLength * 4) + sizeof(uint8_t);
			std::vector<uint8_t> u(len);
			PA_ConvertCharsetToCharset(
																 (char *)t.fString,
																 t.fLength * sizeof(PA_Unichar),
																 eVTC_UTF_16,
																 (char *)&u[0],
																 len,
																 eVTC_UTF_8
																 );
			CUTF8String uti;
			uti = CUTF8String((const uint8_t *)&u[0]);
			CUTF8String typestring;
			size_t pos, found;
			found = 0;
			for(pos = uti.find(';'); pos != CUTF8String::npos; pos = uti.find(';', found))
			{
				typestring = uti.substr(found, pos-found);
				found = pos + 1;
				types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
			}
			typestring = uti.substr(found, uti.length()-found);
			types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
		}
	}
	std::map<CUTF8String, uint32_t>::iterator itr;
	itr = types.find((const uint8_t *)type.c_str());
	if (itr != types.end())
	{
		uint32_t pos = itr->second;
		PA_Handle h = PA_NewHandle(0);
		err = eER_NoErr;
		PA_GetPictureData(*picture, pos, h);
		err = PA_GetLastError();
		if(err == eER_NoErr)
		{
			unsigned long insize = PA_GetHandleSize(h);
			buf.resize(insize);
			memcpy(&buf[0], (const void *)PA_LockHandle(h), insize);
			PA_UnlockHandle(h);
			PA_DisposeHandle(h);
		}
	}
}

void getIcons(PA_Picture *picture,
							std::vector<uint8_t> &png16,
							std::vector<uint8_t> &png32,
							std::vector<uint8_t> &png48,
							std::vector<uint8_t> &png64,
							std::vector<uint8_t> &png128,
							std::vector<uint8_t> &png256)
{
	//96 is automatically rendered by windows
	PA_Picture icon16, icon32, icon48, icon64, icon128, icon256;
	
	PA_Variable args[4];
	
	args[0] = PA_CreateVariable(eVK_Picture);
	args[2] = PA_CreateVariable(eVK_Longint);
	args[3] = PA_CreateVariable(eVK_Longint);
	
	PA_SetPictureVariable(&args[0], PA_DuplicatePicture(*picture, 1));
	
	//Small
	args[1] = PA_CreateVariable(eVK_Picture);
	PA_SetLongintVariable(&args[2], 16);
	PA_SetLongintVariable(&args[3], 16);
	PA_ExecuteCommandByID(679, args, 4);
	icon16 = PA_DuplicatePicture(PA_GetPictureVariable(args[1]), 1);
	PA_ClearVariable(&args[1]);
	
	//
	args[1] = PA_CreateVariable(eVK_Picture);
	PA_SetLongintVariable(&args[2], 32);
	PA_SetLongintVariable(&args[3], 32);
	PA_ExecuteCommandByID(679, args, 4);
	icon32 = PA_DuplicatePicture(PA_GetPictureVariable(args[1]), 1);
	PA_ClearVariable(&args[1]);
	
	//Medium
	args[1] = PA_CreateVariable(eVK_Picture);
	PA_SetLongintVariable(&args[2], 48);
	PA_SetLongintVariable(&args[3], 48);
	PA_ExecuteCommandByID(679, args, 4);
	icon48 = PA_DuplicatePicture(PA_GetPictureVariable(args[1]), 1);
	PA_ClearVariable(&args[1]);
	
	//
	args[1] = PA_CreateVariable(eVK_Picture);
	PA_SetLongintVariable(&args[2], 64);
	PA_SetLongintVariable(&args[3], 64);
	PA_ExecuteCommandByID(679, args, 4);
	icon64 = PA_DuplicatePicture(PA_GetPictureVariable(args[1]), 1);
	PA_ClearVariable(&args[1]);
	
	//
	args[1] = PA_CreateVariable(eVK_Picture);
	PA_SetLongintVariable(&args[2], 128);
	PA_SetLongintVariable(&args[3], 128);
	PA_ExecuteCommandByID(679, args, 4);
	icon128 = PA_DuplicatePicture(PA_GetPictureVariable(args[1]), 1);
	PA_ClearVariable(&args[1]);
	
	//Extra Large
	args[1] = PA_CreateVariable(eVK_Picture);
	PA_SetLongintVariable(&args[2], 256);
	PA_SetLongintVariable(&args[3], 256);
	PA_ExecuteCommandByID(679, args, 4);
	icon256 = PA_DuplicatePicture(PA_GetPictureVariable(args[1]), 1);
	PA_ClearVariable(&args[1]);
	
	PA_ClearVariable(&args[0]);
	PA_ClearVariable(&args[2]);
	PA_ClearVariable(&args[3]);
	
	getPNG(&icon16,  png16);
	getPNG(&icon32,  png32);
	getPNG(&icon48,  png48);
	getPNG(&icon64,  png64);
	getPNG(&icon128, png128);
	getPNG(&icon256, png256);
	
	PA_DisposePicture(icon16);
	PA_DisposePicture(icon32);
	PA_DisposePicture(icon48);
	PA_DisposePicture(icon64);
	PA_DisposePicture(icon128);
	PA_DisposePicture(icon256);
}

#pragma mark -

#if VERSIONWIN

BOOL CALLBACK myEnumResNameProc(
		HMODULE  hModule,
		LPCTSTR  lpszType,
		LPTSTR   lpszName,
		LONG_PTR lParam)
{
	ARRAY_TEXT *resourceIds = (ARRAY_TEXT *)lParam;
	
	if(hModule)
	{
		if(!IS_INTRESOURCE(lpszName))
		{
			resourceIds->appendUTF16String((const PA_Unichar*)lpszName);
		}else{
			//char buf [33];
			//CUTF8String u8 = CUTF8String((uint8_t *)itoa((unsigned int)lpszName, buf, 10));
			//resourceIds->appendUTF8String(&u8);
		}
	}
	return resourceIds->getSize() == 0;
}

BOOL myEnumResLangProc(
								HANDLE hModule,
								LPCTSTR lpszType,
								LPCTSTR lpszName,
								WORD wIDLanguage,
								LONG_PTR lParam
)
{
	std::vector<WORD> *iconGroupLangIds = (std::vector<WORD> *)lParam;
	
	if(hModule)
	{		
		iconGroupLangIds->push_back(wIDLanguage);
		
		return FALSE;
	}
	return TRUE;
}
#endif

void SET_APPLICATION_ICON(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_PICTURE Param2;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	PA_Picture picture = *(PA_Picture *)(pParams[1]);
	
	//convert to png
	PA_Variable args[2];
	args[0] = PA_CreateVariable(eVK_Picture);
	args[1] = PA_CreateVariable(eVK_Unistring);
	PA_SetPictureVariable(&args[0], PA_DuplicatePicture(picture, 1));
	PA_Unistring u = PA_CreateUnistring((PA_Unichar *)".\0p\0n\0g\0\0\0");
	PA_SetStringVariable(&args[1], &u);
	PA_ExecuteCommandByID(1002, args, 2);
	picture = PA_DuplicatePicture(PA_GetPictureVariable(args[0]), 1);
	PA_ClearVariable(&args[0]);
	PA_ClearVariable(&args[1]);
	
	std::vector<uint8_t> png16;
	std::vector<uint8_t> png32;
	std::vector<uint8_t> png48;
	std::vector<uint8_t> png64;
	std::vector<uint8_t> png128;
	std::vector<uint8_t> png256;
	
	getIcons(&picture, png16, png32, png48, png64, png128, png256);
	
	PA_DisposePicture(picture);
	
#if VERSIONWIN
	
	ARRAY_TEXT iconGroupIds;
	std::vector<WORD> iconGroupLangIds;

	std::vector<unsigned int> iconResourceIds;
	unsigned int iconResourceId = 1;
	
	HMODULE hModule = LoadLibraryEx((LPCWSTR)Param1.getUTF16StringPtr(), NULL, LOAD_LIBRARY_AS_DATAFILE);
	
	CUTF16String iconGroupId((const PA_Unichar *)L"MAINICON");
	WORD iconLangId =  MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);

	if(hModule)
	{
		//find available icon IDs
		do {
			PA_YieldAbsolute();
			if(!FindResource(hModule, MAKEINTRESOURCE(iconResourceId), RT_ICON))
			{
				iconResourceIds.push_back(iconResourceId);
			}
			iconResourceId++;
		}while(iconResourceIds.size() < 6);

		//by default, 4D uses APPICON, not MAINICON
		EnumResourceNames(hModule, RT_GROUP_ICON, (ENUMRESNAMEPROC)myEnumResNameProc, (LONG_PTR)&iconGroupIds);
				
		if (iconGroupIds.getSize() != 0)
		{
			iconGroupIds.copyUTF16StringAtIndex(&iconGroupId, 0);
			EnumResourceLanguages(hModule, RT_GROUP_ICON, (LPCWSTR)iconGroupId.c_str(), (ENUMRESLANGPROC)myEnumResLangProc, (LONG_PTR)&iconGroupLangIds);
			if (iconGroupLangIds.size() != 0)
			{
				iconLangId = iconGroupLangIds.at(0);
			}
		}
		
		FreeLibrary(hModule);
	}
	
	HANDLE hResouce = BeginUpdateResource((LPCWSTR)Param1.getUTF16StringPtr(), FALSE);
	
	if(hResouce)
	{
		GroupIconHeader iconHeader;
		//IconFileHeader
		iconHeader.reserved = 0;
		iconHeader.resourceType = 1;
		iconHeader.resourceCount = 6;
		//IconGroupHeader
		iconHeader.resources[0].width			= 0;
		iconHeader.resources[0].height			= 0;
		iconHeader.resources[0].color			= 0;
		iconHeader.resources[0].reserved		= 0;
		iconHeader.resources[0].colorPlanes	= 1;
		iconHeader.resources[0].bitsPerPixel	= 32;
		iconHeader.resources[0].dataSize		= png256.size();
		iconHeader.resources[0].resourceID		= iconResourceIds.at(0);
		//IconGroupHeader
		iconHeader.resources[1].width			= 128;
		iconHeader.resources[1].height			= 128;
		iconHeader.resources[1].color			= 0;
		iconHeader.resources[1].reserved		= 0;
		iconHeader.resources[1].colorPlanes	= 1;
		iconHeader.resources[1].bitsPerPixel	= 32;
		iconHeader.resources[1].dataSize		= png128.size();
		iconHeader.resources[1].resourceID		= iconResourceIds.at(1);
		//IconGroupHeader
		iconHeader.resources[2].width			= 64;
		iconHeader.resources[2].height			= 64;
		iconHeader.resources[2].color			= 0;
		iconHeader.resources[2].reserved		= 0;
		iconHeader.resources[2].colorPlanes	= 1;
		iconHeader.resources[2].bitsPerPixel	= 32;
		iconHeader.resources[2].dataSize		= png64.size();
		iconHeader.resources[2].resourceID		= iconResourceIds.at(2);
		//IconGroupHeader
		iconHeader.resources[3].width			= 48;
		iconHeader.resources[3].height			= 48;
		iconHeader.resources[3].color			= 0;
		iconHeader.resources[3].reserved		= 0;
		iconHeader.resources[3].colorPlanes	= 1;
		iconHeader.resources[3].bitsPerPixel	= 32;
		iconHeader.resources[3].dataSize		= png48.size();
		iconHeader.resources[3].resourceID		= iconResourceIds.at(3);
		//IconGroupHeader
		iconHeader.resources[4].width			= 32;
		iconHeader.resources[4].height			= 32;
		iconHeader.resources[4].color			= 0;
		iconHeader.resources[4].reserved		= 0;
		iconHeader.resources[4].colorPlanes	= 1;
		iconHeader.resources[4].bitsPerPixel	= 32;
		iconHeader.resources[4].dataSize		= png32.size();
		iconHeader.resources[4].resourceID		= iconResourceIds.at(4);
		//IconGroupHeader
		iconHeader.resources[5].width			= 16;
		iconHeader.resources[5].height			= 16;
		iconHeader.resources[5].color			= 0;
		iconHeader.resources[5].reserved		= 0;
		iconHeader.resources[5].colorPlanes	= 1;
		iconHeader.resources[5].bitsPerPixel	= 32;
		iconHeader.resources[5].dataSize		= png16.size();
		iconHeader.resources[5].resourceID		= iconResourceIds.at(5);
		
		LPVOID p[6];
		p[0] = (LPVOID)&png256[0];
		p[1] = (LPVOID)&png128[0];
		p[2] = (LPVOID)&png64[0];
		p[3] = (LPVOID)&png48[0];
		p[4] = (LPVOID)&png32[0];
		p[5] = (LPVOID)&png16[0];
		
		//update images
		for(unsigned int i = 0; i < 6; ++i)
		{
			if(!UpdateResource(
										 hResouce,
										 RT_ICON,
										 MAKEINTRESOURCE(iconHeader.resources[i].resourceID),
										 iconLangId,
										 (LPVOID)p[i],
										 iconHeader.resources[i].dataSize
										 ))
			{
				char str[100];
				sprintf_s(str, "UpdateResource:RT_ICON failed! %d \n", GetLastError());
				OutputDebugStringA(str);
			}
		}

		//update group resource
		if(!UpdateResource(
									 hResouce,
									 RT_GROUP_ICON,
									 (LPCWSTR)iconGroupId.c_str() ,
									 iconLangId,
									 &iconHeader,
									 sizeof(IconFileHeader) + (iconHeader.resourceCount * sizeof(IconGroupHeader))
									 ))
		{
			char str[100];
			sprintf_s(str, "UpdateResource:RT_GROUP_ICON failed! %d \n", GetLastError());
			OutputDebugStringA(str);
		}
				
		if(!EndUpdateResource(hResouce, FALSE))
		{
			char str[100];
			sprintf_s(str, "EndUpdateResource failed! %d \n", GetLastError());
			OutputDebugStringA(str);
		}
	}
#endif
}
